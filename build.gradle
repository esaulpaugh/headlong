import java.text.SimpleDateFormat
import java.security.MessageDigest

plugins {
    id("java-library")
    id("maven-publish")
}

group = "com.esaulpaugh"
version = "13.3.2-SNAPSHOT"

final int gradleMajorVersion = gradle.gradleVersion.tokenize('.')[0] as int

System.out.println("gradleMajorVersion = " + gradleMajorVersion)

if (gradleMajorVersion >= 5) {
    java {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
} else {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

compileJava {
    if (JavaVersion.current() >= JavaVersion.VERSION_1_10) {
        options.compilerArgs.addAll(["--release", "8"])
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    if (gradleMajorVersion >= 6) getArchiveClassifier().set("javadoc")
    else classifier = "javadoc"
    from javadoc.destinationDir
}

task sourcesJar(type: Jar, dependsOn: classes) {
    if (gradleMajorVersion >= 6) getArchiveClassifier().set("sources")
    else classifier = "sources"
    from sourceSets.main.allSource
}

static String todayUTC() {
    SimpleDateFormat sdf = new SimpleDateFormat("MMMM d yyyy")
    sdf.setTimeZone(TimeZone.getTimeZone("UTC"))
    return sdf.format(new Date())
}

jar {
    manifest {
        attributes(
                "Implementation-Title": project.name,
                "Implementation-Version": project.version,
                "Automatic-Module-Name": "com.esaulpaugh.headlong",
                "Created-By": "Gradle",
                "Build-Date": todayUTC()
        )
    }
}

assemble.dependsOn(javadocJar, sourcesJar)

publishing {
    publications {
        headlong(MavenPublication) {
            from components.java
            artifact sourcesJar
            artifact javadocJar
        }
    }
}

sourceSets {
    jmh {
        java.srcDirs = ["src/jmh/java"]
        compileClasspath += sourceSets.main.runtimeClasspath
    }
}

repositories {
    mavenCentral()
}

ext {
    junitVersion = "5.11.4"
    junitPlatformVersion = "1.11.4"
    bcVersion = "1.83"
    jmhVersion = "1.37"
}

dependencies {
    implementation("com.google.code.gson:gson:[2.1,2.13.2]") {
        exclude group: "com.google.errorprone", module: "error_prone_annotations"
    }

    testImplementation("org.junit.jupiter:junit-jupiter-api:${junitVersion}")
    testImplementation("org.bouncycastle:bcprov-jdk14:${bcVersion}")

    testRuntimeOnly("org.junit.platform:junit-platform-console-standalone:${junitPlatformVersion}")

    jmhImplementation("org.openjdk.jmh:jmh-core:${jmhVersion}")
    jmhAnnotationProcessor("org.openjdk.jmh:jmh-generator-annprocess:${jmhVersion}")
}

task consoleTest(type: JavaExec) {
    group = "verification"
    description = "Run tests via junit-platform-console-standalone"

    classpath = sourceSets.test.runtimeClasspath
    main = "org.junit.platform.console.ConsoleLauncher"

    args "--scan-classpath", "--disable-banner"
}

test {
    useJUnitPlatform()
    maxParallelForks = Runtime.runtime.availableProcessors()
}

task jmh(type: JavaExec, dependsOn: jmhClasses) { // run benchmarks with `gradle jmh`
    if (gradleMajorVersion >= 7) getMainClass().set("org.openjdk.jmh.Main")
    else main = "org.openjdk.jmh.Main"
    classpath = sourceSets.jmh.compileClasspath + sourceSets.jmh.runtimeClasspath
}

classes.finalizedBy(jmhClasses)

// tasks.withType(AbstractArchiveTask).configureEach {
tasks.withType(AbstractArchiveTask) {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}

final def artifactsToPublish = [
        "com.google.code.gson:gson:2.13.2",
        "org.junit.platform:junit-platform-console-standalone:1.11.4",
        "org.junit.jupiter:junit-jupiter-api:5.11.4",
        "org.bouncycastle:bcprov-jdk14:1.83",
        "org.openjdk.jmh:jmh-core:1.37",
        "org.openjdk.jmh:jmh-generator-annprocess:1.37"
]

final def localMavenRepo = new File(System.getProperty("user.home"), ".m2/repository")

def copyWithHash(File sourceFile, File targetFile) {
    if (!targetFile.exists()) {
        copy {
            from sourceFile
            into targetFile.parentFile
        }

        MessageDigest md = MessageDigest.getInstance("SHA-1")
        sourceFile.withInputStream { is ->
            byte[] buffer = new byte[8192]
            int read
            while ((read = is.read(buffer)) != -1) md.update(buffer, 0, read)
        }
        def sha1 = md.digest().collect { String.format("%02x", it) }.join()
        new File(targetFile.parentFile, targetFile.name + ".sha1").text = sha1

        return true
    }
    return false
}

// run with option --no-configuration-cache
task populateM2 {
    group = "publishing"
    description = "Copies selected artifacts (JAR + POM + SHA-1) into local Maven repository"

    doLast {
        artifactsToPublish.each { gav ->
            def (group, name, ver) = gav.split(":")

            def dep = dependencies.create("${group}:${name}:${ver}") {
                if (group == 'com.google.code.gson' && name == 'gson') {
                    exclude group: 'com.google.errorprone', module: 'error_prone_annotations'
                }
            }

            def resolvedArtifacts = configurations.detachedConfiguration(dep).resolvedConfiguration.resolvedArtifacts

            resolvedArtifacts.each { artifact ->
                def id = artifact.moduleVersion.id
                def groupPath = id.group.replace('.', '/')
                def targetDir = new File(localMavenRepo, "${groupPath}/${id.name}/${id.version}")
                targetDir.mkdirs()

                // Copy JAR with SHA-1
                def targetJar = new File(targetDir, artifact.file.name)
                if (copyWithHash(artifact.file, targetJar)) {
                    println "Copying JAR ${artifact.file.name} -> ${targetDir} (with SHA-1)"
                    // Copy POM with SHA-1
                    try {
                        def pomDep = dependencies.create("${id.group}:${id.name}:${id.version}@pom")
                        def pomFiles = configurations.detachedConfiguration(pomDep).resolve()

                        pomFiles.each { pomFile ->
                            def targetPom = new File(targetDir, pomFile.name)
                            if (copyWithHash(pomFile, targetPom)) {
                                println "Copying POM ${pomFile.name} -> ${targetDir} (with SHA-1)"
                            } else {
                                println "Skipping POM ${pomFile.name}, already exists"
                            }
                        }
                    } catch (Exception ignored) {
                        println "No POM available for ${id.group}:${id.name}:${id.version}"
                    }
                } else {
                    println "Skipping JAR ${artifact.file.name}, already exists"
                }
            }
        }
    }
}
import org.gradle.api.tasks.JavaExec
import org.gradle.api.tasks.bundling.Jar
import org.gradle.api.tasks.bundling.AbstractArchiveTask
import org.gradle.api.artifacts.ResolvedArtifact
import java.io.File
import java.text.SimpleDateFormat
import java.util.Date
import java.util.TimeZone
import java.security.MessageDigest

plugins {
    `java-library`
    `maven-publish`
}

group = "com.esaulpaugh"
version = "13.3.2-SNAPSHOT"

java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

tasks.withType<JavaCompile> {
    if (JavaVersion.current() >= JavaVersion.VERSION_1_10) {
        options.compilerArgs.addAll(listOf("--release", "8"))
    }
    options.encoding = "UTF-8"
}

fun todayUTC(): String {
    val sdf = SimpleDateFormat("MMMM d yyyy")
    sdf.timeZone = TimeZone.getTimeZone("UTC")
    return sdf.format(Date())
}

fun Jar.setClassifierCompat(classifierValue: String) {
    try {
        val archiveClassifierProp = this::class.java.getMethod("getArchiveClassifier")
        val provider = archiveClassifierProp.invoke(this)
        val setMethod = provider::class.java.getMethod("set", Any::class.java)
        setMethod.invoke(provider, classifierValue)
    } catch (_: Exception) {
        val classifierMethod = this::class.java.getMethod("setClassifier", String::class.java)
        classifierMethod.invoke(this, classifierValue)
    }
}

val javadocJar by tasks.creating(Jar::class) {
    dependsOn(tasks.javadoc)
    setClassifierCompat("javadoc")
    from(tasks.javadoc.get().destinationDir)
}

val sourcesJar by tasks.creating(Jar::class) {
    dependsOn(tasks.classes)
    setClassifierCompat("sources")
    from(sourceSets["main"].allSource)
}

tasks.named("assemble") {
    dependsOn(javadocJar, sourcesJar)
}

tasks.withType<Jar> {
    manifest {
        attributes(
            "Implementation-Title" to project.name,
            "Implementation-Version" to project.version,
            "Automatic-Module-Name" to "com.esaulpaugh.headlong",
            "Created-By" to "Gradle KTS",
            "Build-Date" to todayUTC()
        )
    }
}

sourceSets {
    create("jmh") {
        java.srcDirs("src/jmh/java")
        compileClasspath += sourceSets["main"].runtimeClasspath
    }
}

repositories {
    mavenCentral()
}

val junitVersion = "5.11.4"
val junitPlatformVersion = "1.11.4"
val bcVersion = "1.83"
val jmhVersion = "1.37"

dependencies {
    implementation("com.google.code.gson:gson:[2.1,2.13.2]") {
        exclude(group = "com.google.errorprone", module = "error_prone_annotations")
    }

    testImplementation("org.junit.jupiter:junit-jupiter-api:$junitVersion")
    testImplementation("org.bouncycastle:bcprov-jdk14:$bcVersion")

    testRuntimeOnly("org.junit.platform:junit-platform-console-standalone:$junitPlatformVersion")

    "jmhImplementation"("org.openjdk.jmh:jmh-core:$jmhVersion")
    "jmhAnnotationProcessor"("org.openjdk.jmh:jmh-generator-annprocess:$jmhVersion")
}

val consoleTest by tasks.creating(JavaExec::class) {
    group = "verification"
    description = "Run tests via junit-platform-console-standalone"

    classpath = sourceSets["test"].runtimeClasspath
    setMainCompat("org.junit.platform.console.ConsoleLauncher")

    args("--scan-classpath", "--disable-banner")
}

tasks.named<Test>("test") {
    dependsOn(consoleTest)
    enabled = false
}

// Reflection helper for JavaExec main class (Gradle <7 / >=7 compatibility)
fun JavaExec.setMainCompat(mainValue: String) {
    try {
        val mainClassProp = this::class.java.getMethod("getMainClass")
        val provider = mainClassProp.invoke(this)
        val setMethod = provider::class.java.getMethod("set", Any::class.java)
        setMethod.invoke(provider, mainValue)
    } catch (_: Exception) {
        val mainMethod = this::class.java.getMethod("setMain", String::class.java)
        mainMethod.invoke(this, mainValue)
    }
}

val jmh by tasks.creating(JavaExec::class) {
    dependsOn("jmhClasses")
    setMainCompat("org.openjdk.jmh.Main")
    classpath = sourceSets["jmh"].compileClasspath + sourceSets["jmh"].runtimeClasspath
}

tasks.named("classes") {
    finalizedBy("jmhClasses")
}

tasks.withType<AbstractArchiveTask> {
    isPreserveFileTimestamps = false
    isReproducibleFileOrder = true
}

// ------------------ Populate Maven Local Task ------------------
val artifactsToPublish = listOf(
    "com.google.code.gson:gson:2.13.2",
    "org.junit.platform:junit-platform-console-standalone:1.11.4",
    "org.junit.jupiter:junit-jupiter-api:5.11.4",
    "org.bouncycastle:bcprov-jdk14:1.83",
    "org.openjdk.jmh:jmh-core:1.37",
    "org.openjdk.jmh:jmh-generator-annprocess:1.37"
)

fun computeSha1(f: File): String {
    val md = MessageDigest.getInstance("SHA-1")
    f.inputStream().use { input ->
        val buffer = ByteArray(8192)
        var read: Int = 0
        while (input.read(buffer).also { read = it } != -1) {
            md.update(buffer, 0, read)
        }
    }
    return md.digest().joinToString("") { "%02x".format(it) }
}

fun copyWithHash(sourceFile: File, targetFile: File): Boolean {
    if (!targetFile.exists()) {
        project.copy {
            from(sourceFile)
            into(targetFile.parentFile)
        }

        val sourceHash = computeSha1(sourceFile)
        val targetHash = computeSha1(targetFile)

        if (targetHash != sourceHash) {
            throw IllegalStateException("copy corrupted")
        }

        File(targetFile.parentFile, targetFile.name + ".sha1").writeText(targetHash)

        return true
    }
    return false
}

val localMavenRepo = File(System.getProperty("user.home"), ".m2/repository")

tasks.register("populateM2") {
    group = "publishing"
    description = "Copies selected artifacts (JAR + POM + SHA-1) into local Maven repository"

    doLast {
        artifactsToPublish.forEach { gav ->
            val (group, name, version) = gav.split(":")

            val dep = dependencies.create("$group:$name:$version")
            if (dep is org.gradle.api.artifacts.ModuleDependency) {
                if (group == "com.google.code.gson" && name == "gson") {
                    dep.exclude(mapOf("group" to "com.google.errorprone", "module" to "error_prone_annotations"))
                }
            }

            val resolvedArtifacts: Set<ResolvedArtifact> =
                configurations.detachedConfiguration(dep).resolvedConfiguration.resolvedArtifacts

            resolvedArtifacts.forEach { artifact ->
                val id = artifact.moduleVersion.id
                val groupPath = id.group.replace('.', '/')
                val targetDir = File(localMavenRepo, "$groupPath/${id.name}/${id.version}")
                targetDir.mkdirs()

                // Copy JAR with SHA-1
                val targetJar = File(targetDir, artifact.file.name)
                if (copyWithHash(artifact.file, targetJar)) {
                    println("Copying JAR ${artifact.file.name} -> $targetDir (with SHA-1)")

                    // Copy POM with SHA-1
                    try {
                        val pomDep = dependencies.create("${id.group}:${id.name}:${id.version}@pom")
                        val pomFiles = configurations.detachedConfiguration(pomDep).resolve()

                        pomFiles.forEach { pomFile ->
                            val targetPom = File(targetDir, pomFile.name)
                            if (copyWithHash(pomFile, targetPom)) {
                                println("Copying POM ${pomFile.name} -> $targetDir (with SHA-1)")
                            } else {
                                println("Skipping POM ${pomFile.name}, already exists")
                            }
                        }
                    } catch (_: Exception) {
                        println("No POM available for ${id.group}:${id.name}:${id.version}")
                    }
                } else {
                    println("Skipping JAR ${artifact.file.name}, already exists")
                }
            }
        }
    }
}

publishing {
    publications {
        create<MavenPublication>("headlong") {
            from(components["java"])
            artifact(sourcesJar)
            artifact(javadocJar)
        }
    }
}
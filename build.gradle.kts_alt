import org.gradle.api.tasks.JavaExec
import org.gradle.api.tasks.bundling.Jar
import org.gradle.api.artifacts.ResolvedArtifact
import java.text.SimpleDateFormat
import java.util.Date
import java.util.TimeZone

plugins {
    `java-library`
    `maven-publish`
}

group = "com.esaulpaugh"
version = "13.3.2-SNAPSHOT"

java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

tasks.withType<JavaCompile> {
    if (JavaVersion.current() >= JavaVersion.VERSION_1_10) {
        options.compilerArgs.addAll(listOf("--release", "8"))
    }
    options.encoding = "UTF-8"
}

fun todayUTC(): String {
    val sdf = SimpleDateFormat("MMMM d yyyy")
    sdf.timeZone = TimeZone.getTimeZone("UTC")
    return sdf.format(Date())
}

fun Jar.setClassifierCompat(classifierValue: String) {
    try {
        val archiveClassifierProp = this::class.java.getMethod("getArchiveClassifier")
        val provider = archiveClassifierProp.invoke(this)
        val setMethod = provider::class.java.getMethod("set", Any::class.java)
        setMethod.invoke(provider, classifierValue)
    } catch (_: Exception) {
        val classifierMethod = this::class.java.getMethod("setClassifier", String::class.java)
        classifierMethod.invoke(this, classifierValue)
    }
}

val javadocJar by tasks.creating(Jar::class) {
    dependsOn(tasks.javadoc)
    setClassifierCompat("javadoc")
    from(tasks.javadoc.get().destinationDir)
}

val sourcesJar by tasks.creating(Jar::class) {
    dependsOn(tasks.classes)
    setClassifierCompat("sources")
    from(sourceSets["main"].allSource)
}

tasks.named("assemble") {
    dependsOn(javadocJar, sourcesJar)
}

tasks.withType<Jar> {
    manifest {
        attributes(
            "Implementation-Title" to project.name,
            "Implementation-Version" to project.version,
            "Automatic-Module-Name" to "com.esaulpaugh.headlong",
            "Created-By" to "Gradle KTS",
            "Build-Date" to todayUTC()
        )
    }
}

sourceSets {
    create("jmh") {
        java.srcDirs("src/jmh/java")
        compileClasspath += sourceSets["main"].runtimeClasspath
    }
}

repositories {
    mavenCentral()
}

val junitVersion = "5.11.4"
val junitPlatformVersion = "1.11.4"
val bcVersion = "1.83"
val jmhVersion = "1.37"

dependencies {
    implementation("com.google.code.gson:gson:[2.1,2.13.2]") {
        exclude(group = "com.google.errorprone", module = "error_prone_annotations")
    }

    testImplementation("org.junit.jupiter:junit-jupiter-api:$junitVersion")
    testImplementation("org.bouncycastle:bcprov-jdk14:$bcVersion")

    testRuntimeOnly("org.junit.platform:junit-platform-console-standalone:$junitPlatformVersion")

    "jmhImplementation"("org.openjdk.jmh:jmh-core:$jmhVersion")
    "jmhAnnotationProcessor"("org.openjdk.jmh:jmh-generator-annprocess:$jmhVersion")
}

val consoleTest by tasks.creating(JavaExec::class) {
    group = "verification"
    description = "Run tests via junit-platform-console-standalone"

    classpath = sourceSets["test"].runtimeClasspath
    mainClass.set("org.junit.platform.console.ConsoleLauncher")

    args("--scan-classpath", "--disable-banner")
}

tasks.named<Test>("test") {
    dependsOn(consoleTest)
    enabled = false
}

// Reflection helper for JavaExec main class (Gradle <7 / >=7 compatibility)
fun JavaExec.setMainCompat(mainValue: String) {
    try {
        val mainClassProp = this::class.java.getMethod("getMainClass")
        val provider = mainClassProp.invoke(this)
        val setMethod = provider::class.java.getMethod("set", Any::class.java)
        setMethod.invoke(provider, mainValue)
    } catch (_: Exception) {
        val mainMethod = this::class.java.getMethod("setMain", String::class.java)
        mainMethod.invoke(this, mainValue)
    }
}

val jmh by tasks.creating(JavaExec::class) {
    dependsOn("jmhClasses")
    setMainCompat("org.openjdk.jmh.Main")
    classpath = sourceSets["jmh"].compileClasspath + sourceSets["jmh"].runtimeClasspath
}

tasks.named("classes") {
    finalizedBy("jmhClasses")
}

tasks.withType<AbstractArchiveTask> {
    isPreserveFileTimestamps = false
    isReproducibleFileOrder = true
}

// ------------------ Populate Maven Local Task ------------------
val localMavenRepo = File(System.getProperty("user.home"), ".m2/repository")

val artifactsToPublish = listOf(
    "com.google.code.gson:gson:2.13.2",
    "org.junit.platform:junit-platform-console-standalone:1.11.4",
    "org.junit.jupiter:junit-jupiter-api:5.11.4",
    "org.bouncycastle:bcprov-jdk14:1.83",
    "org.openjdk.jmh:jmh-core:1.37",
    "org.openjdk.jmh:jmh-generator-annprocess:1.37"
)

tasks.register("populateM2") {
    doLast {
        artifactsToPublish.forEach { gav ->
            val (group, name, version) = gav.split(":")
            val dep = dependencies.create("$group:$name:$version")
            if (dep is org.gradle.api.artifacts.ModuleDependency) {
                if (group == "com.google.code.gson") {
                    dep.exclude(group = "com.google.errorprone", module = "error_prone_annotations")
                }
            }

            val resolvedArtifacts: Set<ResolvedArtifact> =
                configurations.detachedConfiguration(dep).resolvedConfiguration.resolvedArtifacts

            resolvedArtifacts.forEach { artifact ->
                val id = artifact.moduleVersion.id
                val groupPath = id.group.replace('.', '/')
                val targetDir = File(localMavenRepo, "$groupPath/${id.name}/${id.version}")
                targetDir.mkdirs()

                val jarFile = artifact.file
                val targetJar = File(targetDir, jarFile.name)
                if (!targetJar.exists()) {
                    println("Copying JAR ${jarFile.name} -> $targetDir")
                    copy {
                        from(jarFile)
                        into(targetDir)
                    }
                } else {
                    println("Skipping JAR ${jarFile.name}, already exists")
                }

                // attempt to copy .pom file
                val pomCandidates = fileTree(File(System.getProperty("user.home"), ".gradle/caches/modules-2/files-2.1")) {
                    include("**/${id.name}/${id.version}/**/*.pom")
                }
                if (pomCandidates.files.isNotEmpty()) {
                    val sourcePom = pomCandidates.files.first()
                    val targetPom = File(targetDir, "${id.name}-${id.version}.pom")
                    if (!targetPom.exists()) {
                        println("Copying POM ${sourcePom.name} -> $targetDir")
                        copy {
                            from(sourcePom)
                            into(targetDir)
                        }
                    } else {
                        println("Skipping POM ${sourcePom.name}, already exists")
                    }
                } else {
                    println("No POM found for ${id.group}:${id.name}:${id.version}, skipping")
                }
            }
        }
    }
}

publishing {
    publications {
        create<MavenPublication>("headlong") {
            from(components["java"])
            artifact(sourcesJar)
            artifact(javadocJar)
        }
    }
}